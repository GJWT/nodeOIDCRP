<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: service.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: service.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const Message = require('../nodeOIDCMsg/src/oicMsg/message');
const ErrorResponse = require('../nodeOIDCMsg/src/oicMsg/oauth2/responses').ErrorResponse;
const HttpLib = require('./http');
const AuthorizationResponse =
    require('../nodeOIDCMsg/src/oicMsg/oauth2/init.js').AuthorizationResponse;
const util = require('./util').Util;
const urlParse = require('url-parse');
const Util = require('./util').Util;

/**
 * @fileoverview Method call structure for Services
 * do_request_init
 *  - request_info
 *  - construct
 *      - pre_construct (*)
 *      - parse_args
 *      - post_construct (*)
 *  - init_authentication_method
 *  - uri_and_body
 *      - _endpoint
 *  - update_http_args
 *
 * service_request
 *   - parse_request_response
 *      - parse_response
 *         - get_urlinfo
 *              - post_parse_response (*)
 *      - parse_error_mesg
 *
 * The methods marked with (*) are where service specific
 * behaviour is implemented.
 */

let SUCCESSFUL = [200, 201, 202, 203, 204, 205, 206];
let SPECIAL_ARGS = ['authn_endpoint', 'algs'];
let REQUEST_INFO =
    'Doing request with: URL:{}, method:{}, data:{}, https_args:{}';

/**
 * Service
 * @class
 * @constructor
 */
class Service {
  constructor() {
    /** 
     * The message subclass that describes the request. Default is Message 
     * @type {Message} 
     */ 
    this.msgType = Message;

    /** 
     * The message subclass that describes the response. Default is Message 
     * @type {Message}
     */
    this.responseCls = Message;

    /** The message subclass that describes an error response. Default is oauth2 ErrorResponse
     * @type {ErrorResponse}
     */
    this.errorMsg = ErrorResponse;

    /** The name of the endpoint on the server that the request should be sent to. No default 
     * @type {string}
     */
    this.endpointName = '';

    /** 
     * True if the response will be returned as a direct response to the request. The only exception 
     * right now to this is the Authorization request where the response is delivered to the client 
     * at some later date. Default is True 
     * @type {bool}
     */
    this.synchronous = true;

    /** 
     * A name of the service. Later when a RP/client is implemented instances of different services are found by using this name. No default 
     * @type {string}
     */
    this.request = '';

    /** 
     * The client authentication method to use if nothing else is specified. Default is ‘’ which means none. 
     * @type {string}
     */
    this.defaultAuthMethod = '';

    /** Which HTTP method to use when sending the request. Default is GET 
     * @type {string}
     */
    this.httpMethod = 'GET';

    /** The serialization method to be used for the request Default is urlencoded 
     * @type {string}
     */
    this.bodyType = 'urlEncoded';

    /** The deserialization method to use on the response Default is json 
     * @type {string}
     */
    this.responseBodyType = 'json';

    this.events = null;
    this.endpoint = '';
    this.defaultRequestArgs = {};

    // pull in all the modifiers
    this.preConstruct = [];
    this.postConstruct = [];
    this.postParseResponse = [];
  }

  init(httpLib, keyJar, clientAuthMethod, kwargs) {
    this.httpLib = httpLib || null;
    this.keyJar = keyJar || null;
    this.clientAuthMethod = clientAuthMethod || null;
  }

  /**
   * Go through the attributes that the message class can contain and
   * add values if they are missing and exists in the client info or
   * when there are default values.
   *
   * @param {ClientInfo} cliInfo Client info
   * @return Object&lt;string, Object> 
   */

  parseArgs(cliInfo, kwargs) {
    let arArgs = kwargs;
    let self = this;
    for (let i = 0; i &lt; Object.keys(this.msgType.cParam).length;
         i++) {
      let prop = Object.keys(this.msgType.cParam)[i];
      if (Object.keys(arArgs).indexOf(prop) !== -1) {
        continue;
      } else {
        if (cliInfo[prop]) {
          arArgs[prop] = cliInfo[prop];
        } else if (this.defaultRequestArgs[prop]) {
          arArgs[prop] = this.defaultRequestArgs[prop];
        }
      }
    }
    return arArgs;
  }

  /**
   * Will run the pre_construct methods one at the time in order. Updates 
   * the arguments in the method call with preconfigure argument from the 
   * client configuration. Then it will run the list of pre_construct methods
   * one by one in the order they appear in the list.
   * 
   * The call API that all the pre_construct methods must adhere to is:
   *    meth(cli_info, request_args, **_args)
   * 
   * CliInfo is an instance of ClientInfo class. The methods MUST return a 
   * tuple with request arguments and arguments to be used by the 
   * postConstruct methods. 
   * 
   * @param {ClientInfo} cliInfo Client Information as a Client instance.
   * @param {Object&lt;string, string>} requestArgs Request arguments
   * @return Array consisting of request arguments and post arguments
   */
  doPreConstruct(cliInfo, requestArgs, kwargs) {
    let postArgs = {};
    let pair = null;
    for (let i = 0; i &lt; this.preConstruct.length; i++) {
      let meth = this.preConstruct[i];
      pair = meth(cliInfo, requestArgs, kwargs);
    }
    if (!pair){
      pair = [requestArgs, postArgs];
    }
    return pair;
  }

  /**
   * Has a number of sources where it can get request arguments from. 
   * In priority order:
   * -  Arguments to the method call
   * -  Information kept in the client information instance
   * -  Information in the client configuration targeted for this method.
   * -  Standard protocol defaults.
   * 
   * It will go through the list of possible (required/optional) attributes 
   * as specified in the oicmsg.message.Message class that is defined to be 
   * used for this request and add values to the attributes if any can be 
   * found.
   * 
   * @param {ClientInfo} cliInfo contains client information
   * @return Object&lt;string, Object> that contains request arguments such as
   * redirectUri
   */
  gatherRequestArguments(cliInfo, kwargs) {
    let arArgs = this.parseArgs(cliInfo, kwargs);
    if (Object.keys(arArgs).indexOf('redirect_uri') === -1) {
      try {
        arArgs['redirect_uri'] = cliInfo.redirectUris[0];
      } catch (err) {
        console.log(err);
        console.log('Missing parameter redirect uri');
      }
    }
    return arArgs;
  }

  /**
   * Has a number of sources where it can get request arguments from. In 
   * priority order:
   * -  Arguments to the method call
   * -  Information kept in the client information instance
   * -  Information in the client configuration targeted for this method.
   * -  Standard protocol defaults.
   * 
   * It will go through the list of possible (required/optional) attributes 
   * as specified in the oicmsg.message.Message class that is defined to be 
   * used for this request and add values to the attributes if any can be 
   * found.
   * 
   * @param {ClientInfo} cliInfo Client Information as a oiccli Client instance
   * @param {Object&lt;string, string>} requestArgs Request arguments
   * @param {Object&lt;string, string>} postArgs Arguments used by the 
   * postConstruct method
   * @return Possible modified set of request arguments.
   */
  doPostConstruct(cliInfo, requestArgs, postArgs) {
    let pair = null;
    for (let i = 0; i &lt; this.postConstruct.length; i++) {
      let meth = this.postConstruct[i];
      requestArgs = meth(cliInfo, requestArgs, postArgs);
    }
    return requestArgs;
  }

  /**
   * A method run after the response has been parsed and verified.
   * Runs the list of post_parse_response methods in the order they appear 
   * in the list.
   * 
   * @param {Message} resp The response as a Message instance
   * @param {ClientInfo} cliInfo Client Information as a Client instance.
   * @param {State} state State value
   */
  doPostParseResponse(resp, cliInfo, state, kwargs) {
    state = state || '';
    for (let i = 0; i &lt; this.postParseResponse.length; i++) {
      let meth = this.postParseResponse[i];
      meth(resp, cliInfo, state, kwargs);
    }
  }

  setUp() {
    console.log('Unsupported');
  }

  /**
   * Instantiate the request as a message class instance with
   * attribute values gathered in a preConstruct method or in the
   * gatherRequestArgs method and possibly modified by a postConstruct method.
   * 
   * @param {ClientInfo} cliInfo Information about the client
   * @param {Object&lt;string, string>}requestArgs Request arguments
   * @return Message class instance
   */
  construct(cliInfo, requestArgs, kwargs) {
    if (requestArgs == null) {
      requestArgs = {};
    }
    let pair = this.doPreConstruct(cliInfo, requestArgs, kwargs);
    requestArgs = pair[0];
    let postArgs = pair[1];
    this.msgType = new this.msgType();
    if (this.msgType &amp;&amp;
        Object.keys(this.msgType.cParam).indexOf('state')) {
      if (kwargs &amp;&amp; kwargs['state']) {
        delete kwargs['state'];
      }
    }
    let args = null;
    try {
      args = this.gatherRequestArgs(cliInfo, requestArgs);
    } catch (err) {
      args = this.parseArgs(cliInfo, requestArgs);
    }
    if (this.msgType.cDefault) {
      args = Object.assign({}, this.msgType.cDefault, args);
    }
    return this.doPostConstruct(cliInfo, args, postArgs);
  }

  /**
   *  Find out which endpoint the request should be sent to
   *  Picks the endpoint (URL) to which the request will be sent.
   * @return The endpoint URI to which the request will be sent
   */
  getEndpoint(kwargs) {
    let uri = '';
    if (kwargs) {
      uri = kwargs['endpoint'];
      delete kwargs['endpoint'];
    }
    if (!uri) {
      try {
        uri = this.endpoint;
      } catch (err) {
        console.log('No endpoint specified');
      }
    }
    return uri;
  }
  
  /**
   * Based on the HTTP method place the protocol message in the right place.
   * Depending on where the request are to be placed in the request (part of 
   * the URL or as a POST body) and the serialization used the request in 
   * it’s proper form will be constructed and tagged with destination.
   * 
   * uriAndBody will return a dictionary that a HTTP client library can use 
   * to send the request.
   * 
   * @param {ResourceRequest} cis The request as a Message class instance
   * @param {string} method HTTP method
   */
  uriAndBody(cis, method, kwargs) {
    method = method || 'POST';
    let resp = {}
    let uri = this.getEndpoint(kwargs);
    if (kwargs &amp;&amp; kwargs['headers']){
      resp['hArgs'] = {'headers': kwargs['headers']};
    }
    resp = Object.assign(resp, util.prototype.getOrPost(uri, method, cis, null, null, kwargs));
    resp['cis'] = cis;
    return resp;
  }

  /**
   *  Will run the proper client authentication method.
   *  Each such method will place the necessary information in the necessary
   *  place. A method may modify the request.
   *  Supports 6 different client authentication/authorization methods
   * -  bearerBody
   * -  bearerHeader
   * -  clientSecretBasic
   * -  clientSecretJwt
   * -  clientSecretPost
   * -  privateKeyJwt
   * depending on which of these, if any, is supposed to be used different 
   * things has to happen. Thos things will happen when this method is called.
   * 
   * @param {ResourceRequest} cis The request as a Message class instance
   * @param {ClientInfo} cliInfo ClientInfo instance
   * @param {string} authMethod Type of authentication method
   * @param {Object&lt;string, string>} requestArgs Request args
   * @param {Object&lt;string, string>} httpArgs HTTP header arguments
   * @return Object&lt;string, Object> containing Http arguments 
   */
  initAuthenticationMethod(
      cis, cliInfo, authMethod, requestArgs, httpArgs, kwargs) {
    if (httpArgs == null) {
      httpArgs = {};
    }
    if (requestArgs == null) {
      requestArgs = {};
    }
    if (authMethod) {
      return this.clientAuthMethod[authMethod].prototype.construct(
          cis, cliInfo, requestArgs, httpArgs, kwargs);
    } else {
      return httpArgs;
    }
  }

  /**
   * The method where everything is setup for sending the request.
   * The request information is gathered and the where and how of sending the
   * request is decided.
   * 
   * - Remove request arguments that is know at this point should not appear in
   *   the request
   * - Construct the request
   * - Do the client authentication setup if necessary
   * - Set the necessary HTTP headers
   * 
   * @param {ClientInfo} cliInfo Client information as a oicCli Client instance
   * @param {string} method The HTTP method to be used
   * @param {Object&lt;string, string>} requestArgs Request Arguments
   * @param {string} bodyType If the request is sent in the HTTP body this 
   * decides the encoding of the request
   * @param {string} authnMethod The client authentication method
   * @param {bool} lax If it should be allowed to send a request that doesn't 
   * completely conform to the standard
   * @return A dictionary with the keys 'uri' and possibly 'body', 'kwargs',
   * 'request' and 'ht_args'
   */
  requestInfo(cliInfo, method, requestArgs, bodyType, authMethod, lax, kwargs) {
    if (!method) {
      method = this.httpMethod;
    }

    if (requestArgs == null) {
      requestArgs = {};
    }

    var kwargsArr = [];
    if (kwargs){
      kwargsArr = Object.keys(kwargs);      
    }

    let args = {};
    for (let i = 0; i &lt; kwargsArr.length; i++) {
      let k = kwargsArr[i];
      let v = kwargs[k];
      if (SPECIAL_ARGS.indexOf(v) == -1 &amp;&amp; SPECIAL_ARGS.indexOf(k) == -1) {
        args[k] = v;
      }
    }

    let cis = this.construct(cliInfo, requestArgs, args);

    if (this.events) {
      this.events.store('Protocol request', cis);
    }

    if (cis &amp;&amp; lax) {
      cis.lax = lax;
    }

    let hArg = null;

    if (authMethod) {
      hArg =
          this.initAuthenticationMethod(cis, cliInfo, authMethod, null, kwargs);
    }

    if (hArg) {
      if (kwargs.headers) {
        kwargs['headers'] = Object.assign(hArg['headers'], kwargs['headers']);
      } else {
        kwargs['headers'] = hArg['headers'];
      }
    }

    if (bodyType == 'json') {
      kwargs['contentType'] = JSON;
    }

    return this.uriAndBody(cis, method, kwargs);
  }

  /**
   * Extending the header with information gathered during the request setup.
   * Will add the HTTP header arguments that has been added while the request
   * has been travelling through the pipe line to a possible starting set.
   * @param {Object&lt;string, string>} httpArgs Original HTTP header arguments
   * @param {Object} info Request info
   */
  updateHttpArgs(httpArgs, info) {
    let hArgs = null;
    if (info['hArgs']){
      hArgs = info['hArgs'];
    } else {
      hArgs = {};
    }

    if (httpArgs == null) {
      httpArgs = hArgs;
    } else {
      httpArgs = info['hArgs'];
    }

    if (info['kwargs'] &amp;&amp; info['kwargs']['headers']){
      const headers = info['kwargs']['headers'];
      httpArgs = {'headers': headers}
    }

    info['httpArgs'] = httpArgs;
    return info;
  }

  /**
   *  Builds the request message and constructs the HTTP headers.
   *  This is the starting pont for a pipeline that will:
   *    - construct the request message
   *    - add/remove information to/from the request message in the way a
   *      specific client authentication method requires.
   *    - gather a set of HTTP headers like Content-type and Authorization.
   *    - serialize the request message into the necessary format (JSON, 
   *      urlencoded, signed JWT)
   * 
   * @param {ClientInfo} cliInfo Client information
   * @param {string} bodyType Which serialization to use for the HTTP body
   * @param {string} method HTTP method used
   * @param {string} authMethod One of the six client authentication methods
   * @param {Object&lt;string, string>} requestArgs Message arguments
   * @param {Object&lt;string, object>} httpArgs Initial HTTP header arguments
   * @return Object&lt;string, Object> contains difference information such as 
   * the uri, body, and httpArgs based on the service
   */
  doRequestInit(
      cliInfo, bodyType, method, authMethod, requestArgs, httpArgs, kwargs) {
    if (!method) {
      method = this.httpMethod;
    }
    if (!authMethod) {
      authMethod = this.defaultAuthnMethod;
    }
    if (!bodyType) {
      bodyType = this.bodyType;
    }
    let info = this.requestInfo(
        cliInfo, method, requestArgs, bodyType, authMethod, httpArgs, kwargs);
    return this.updateHttpArgs(httpArgs, info);
  }

  /************************ RESPONSE HANDLING *************************/

  /**
   *  Pick out the fragment or query part from a URL.
   *  @param info A URL possibly containing a query or a fragment part
   *  @return the query/fragment part
   */
  getUrlInfo(info) {
    let parts = null;
    if (typeof info == 'string'){
      if (info.indexOf('?') !== -1 || info.indexOf('#') !== -1) {
        parts = urlParse(info);
        let query = parts.query;
        let fragment = parts.fragment;
        if (query) {
          info = query.substring(1);
        } else {
          info = fragment;
        }
      }
    }
    return info;
  }

  /**
   * This the start of a pipeline that will:
   *  - Deserializes a response into it's response message class.
   *    Or oauth2 ErrorResponse if it's an error message
   *  - verifies the correctness of the response by running the verify 
   *    method belonging to the message class used.
   *  - runs the doPostParseResponse method iff the response was not
   *    an error response.
   * 
   * @param {Object&lt;string, string>} info The response, can be either in a JSON or an urlencoded format
   * @param {ClientInfo} clientInfo Information about client and server
   * @param {string} sformat Which serialization that was used
   * @param {State} state The state
   * @return Response instance such as an ErrorResponse
   */
  parseResponse(info, clientInfo, sformat, state, kwargs) {
    if (sformat == 'urlencoded') {
      info = this.getUrlInfo(info);
    }

    if (this.events) {
      this.events.store('Response', info);
    }

    let resp = null;
    let responseObj = this.responseCls;    
    try {
      if (sformat === 'urlencoded') {
        resp = responseObj.prototype.fromUrlEncoded(info);
      }else if (sformat === 'json'){
        resp = responseObj.prototype.fromJSON(info);
      }
    } catch (err) {
      console.log('Error while deserializing');
    }

    let msg = 'Initial response parsing';

    if (this.events) {
      this.events.store('Protocol Response', resp);
    }
    let errMsgs = null;
    if (Object.keys(resp).indexOf('error') !== -1 &amp;&amp;
        !(resp instanceof ErrorResponse)) {
      resp = null;
      try {
        errMsgs = [this.errorMsg];
        if (errMsgs.indexOf(ErrorResponse) !== -1) {
          errMsgs.push(ErrorResponse);
        }
      } catch (err) {
        errMsgs = [ErrorResponse];
      }

      try {
        for (let i = 0; i &lt; errMsgs.length; i++) {
          var errMsg = errMsgs[i];
          try {
            if (sformat === 'urlencoded') {
              resp = new errMsg().fromUrlEncoded(info);
              break;
            }
          } catch (err) {
            resp = null;
          }
        }
      } catch (err) {
        console.log(err);
      }
    } else {
      if (!kwargs) {
        kwargs = {};
      }
      kwargs['client_id'] = clientInfo.client_id;
      kwargs['iss'] = clientInfo.issuer;

      if (Object.keys(kwargs).indexOf('key') !== -1 &amp;&amp;
          Object.keys(kwargs).indexOf('keyjar') !== -1) {
        kwargs['keyjar'] = this.keyjar;
      }

      try {
        let responseObj = this.responseCls;
      } catch (err) {
        console.log(err);
      }

      if (Object.keys(resp).indexOf('scope') !== -1) {
        try {
          resp['scope'] = kwargs['scope'];
        } catch (err) {
          console.log(err);
        }
      }
    }
    if (!resp) {
      console.log('Missing or faulty response');
    }

    try {
      this.doPostParseResponse(resp, clientInfo, state);
    } catch (err) {
      console.log(err);
    }
    return resp;
  }

  /**
   * Deal with a request response
   * @param {string} reqresp The HTTP request response
   * @param {string} bodyType How the body is encoded
   * @return ErrorMessage class instance
   */
  parseErrorMessage(reqresp, bodyType) {
    if (bodyType == 'txt'){
      bodyType = 'urlencoded';
    }else{
      bodyType = bodyType;
    }
    let err;
    if (bodyType === 'urlencoded'){
      err = new this.errorMsg().fromUrlEncoded(reqresp.text)
    }else if (bodyType === 'json'){
      err = new this.errorMsg().fromJSON(reqresp.text)
    }
    return err;
  }

  /**
   * Get the encoding of the response
   * @param {string} reqresp The response
   * @param {string} bodyType Assumed body type
   * @return String with the encoding type
   */
  getValueType(reqresp, bodyType) {
    if (bodyType) {
      return Util.prototype.verifyHeader(reqresp, bodyType);
    } else {
      return 'urlencoded';
    }
  }

  /**
   * Deal with a request response
   * @param {string} reqresp The HTTP request response
   * @param {ClientInfo} clientInfo Information about the client/server session
   * @param {string} responseBodyType If response in body one of 'json', 'jwt' or
   *      'urlencoded'
   * @param {State} state Session identifier
   * @return response type such as an ErrorResponse
   */
  parseRequestResponse(reqresp, clientInfo, responseBodyType, state, kwargs) {
    responseBodyType = responseBodyType || '';
    state = state || '';
    let statusCodeArr = [302, 303];

    if (SUCCESSFUL.indexOf(reqresp.statusCode) !== -1) {
      /*
      var type;
      var valueType;
      try{
        type = Util.prototype.getResponseBodyType(reqresp);
      }catch(err){
        valueType = responseBodyType;
      }
      if (type != responseBodyType){
        console.log('Not the expected body type. Expected : ' + type);
      }
      var typeArr = ['json', 'jwt', 'urlencoded'];
      var valueType;
      if (typeArr.indexOf(type) !== -1){
        valueType = type;
      }else{
        valueType = responseBodyType;
      } */
      
      let valueType = this.getValueType(reqresp, responseBodyType);

      try {
        return this.parseResponse(
            reqresp.text, clientInfo, valueType, state, kwargs);
      } catch (err) {
        console.log(err);
      }
    } else if (statusCodeArr.indexOf(reqresp.statusCode) !== -1) {
      return reqresp;
    } else if (reqresp.statusCode === 500) {
      console.log('Something went wrong');
    } else if (400 &lt;= reqresp.statusCode &lt; 500) {
      let valueType = this.getValueType(reqresp, responseBodyType);
      let errResp = null;
      try {
        errResp = this.parseErrorMessage(reqresp, valueType);
      } catch (err) {
        return reqresp.text;
      }
      return errResp;
    } else {
      console.log('Error response');
    }
  }

  /**
  * The method that sends the request and handles the response returned.
  * This assumes a synchronous request-response exchange.
  * @param {string} reqresp The HTTP request response
  * @param {ClientInfo} clientInfo Information about the client/server session
  * @param {string} responseBodyType If response in body one of 'json', 'jwt' or
  *      'urlencoded'
  * @param {State} state Session identifier
  * @return Returns a request response
  */ 
  serviceRequest(reqresp, clientInfo, responseBodyType, state, kwargs) {
    if (httpArgs == null) {
      httpArgs = {};
    }
    try {
      resp = this.httpLib(url, method, data, httpArgs);
      data = data || body;
    } catch (err) {
      console.log('Exception on request');
    }
    if (kwargs.indexOf('keyjar') === -1) {
      kwargs['keyjar'] = this.keyjar;
    }
    if (!responseBodyType) {
      responseBodyType = this.responseBodyType;
    }
    return this.parseRequestResponse(
        resp, clientInfo, responseBodyType, kwargs);
  }
}

module.exports = Service;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AccessToken.html">AccessToken</a></li><li><a href="Authorization.html">Authorization</a></li><li><a href="BearerBody.html">BearerBody</a></li><li><a href="BearerHeader.html">BearerHeader</a></li><li><a href="CheckID.html">CheckID</a></li><li><a href="CheckSession.html">CheckSession</a></li><li><a href="Client.html">Client</a></li><li><a href="ClientAuthnMethod.html">ClientAuthnMethod</a></li><li><a href="ClientInfo.html">ClientInfo</a></li><li><a href="ClientSecretBasic.html">ClientSecretBasic</a></li><li><a href="ClientSecretJWT.html">ClientSecretJWT</a></li><li><a href="ClientSecretPost.html">ClientSecretPost</a></li><li><a href="EndSession.html">EndSession</a></li><li><a href="JRD.html">JRD</a></li><li><a href="JWSAuthnMethod.html">JWSAuthnMethod</a></li><li><a href="LINK.html">LINK</a></li><li><a href="OICCli.html">OICCli</a></li><li><a href="ProviderInfoDiscovery.html">ProviderInfoDiscovery</a></li><li><a href="RefreshAccessToken.html">RefreshAccessToken</a></li><li><a href="Registration.html">Registration</a></li><li><a href="Service.html">Service</a></li><li><a href="State.html">State</a></li><li><a href="StateJWT.html">StateJWT</a></li><li><a href="URINormalizer.html">URINormalizer</a></li><li><a href="UserInfo.html">UserInfo</a></li><li><a href="Util.html">Util</a></li><li><a href="WebFinger.html">WebFinger</a></li></ul><h3>Global</h3><ul><li><a href="global.html#buildServices">buildServices</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Fri Mar 09 2018 11:36:25 GMT-0800 (PST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
